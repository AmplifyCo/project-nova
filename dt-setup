#!/bin/bash
# Digital Twin Setup - Complete automation
# ONE command to: install Python, dependencies, configure, and run
#
# Usage:
#   ./dt-setup              # First run from repo (self-installs)
#   dt-setup                # After install, run from anywhere
#   dt-setup start          # Start the bot
#   dt-setup run            # Start the bot (alias)

# Get the directory where this script is located
# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEFAULT_GLOBAL_DIR="/usr/local/bin"
DEFAULT_LOCAL_DIR="$HOME/.local/bin"
COMMAND_NAME="dt-setup"

# If running from the install location, look for a stored project directory
# If running from the install location, look for a stored project directory
# Check if we are running the installed version (global or local)
if [[ "$SCRIPT_DIR" == "$DEFAULT_GLOBAL_DIR" ]] || [[ "$SCRIPT_DIR" == "$DEFAULT_LOCAL_DIR" ]]; then
    # Check for a stored project path written at install time
    STORED_PROJECT_DIR_FILE="$SCRIPT_DIR/.dt-setup-project-dir"
    if [ -f "$STORED_PROJECT_DIR_FILE" ]; then
        SCRIPT_DIR="$(cat "$STORED_PROJECT_DIR_FILE")"
    fi
fi

CONFIGURE_PY="$SCRIPT_DIR/configure.py"
REQUIREMENTS_TXT="$SCRIPT_DIR/requirements.txt"

# Check if configure.py exists
if [ ! -f "$CONFIGURE_PY" ]; then
    echo "Error: configure.py not found at $CONFIGURE_PY"
    echo "  Expected project directory: $SCRIPT_DIR"
    echo "  If you moved the project, re-run: cd <project-dir> && ./dt-setup"
    exit 1
fi

# ============================================
# Check and install Python if needed
# ============================================
check_python() {
    if ! command -v python3 &> /dev/null; then
        echo ""
        echo "‚ùå Python 3 is not installed!"
        echo ""
        echo "Installing Python 3..."
        echo ""

        # Detect OS and install Python
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS
            if command -v brew &> /dev/null; then
                brew install python3
            else
                echo "Please install Homebrew first: https://brew.sh"
                echo "Then run: brew install python3"
                exit 1
            fi
        elif [[ -f /etc/os-release ]]; then
            . /etc/os-release
            if [[ "$ID" == "amzn" ]] || [[ "$ID_LIKE" == *"rhel"* ]]; then
                # Amazon Linux / RHEL-based
                sudo yum install python3 -y
            elif [[ "$ID" == "ubuntu" ]] || [[ "$ID" == "debian" ]] || [[ "$ID_LIKE" == *"debian"* ]]; then
                # Debian/Ubuntu
                sudo apt-get update && sudo apt-get install python3 python3-pip -y
            else
                echo "‚ö†Ô∏è  Unsupported Linux distribution: $ID"
                echo "   Please install Python 3 manually"
                exit 1
            fi
        else
            echo "‚ö†Ô∏è  Unsupported operating system"
            echo "   Please install Python 3 manually"
            exit 1
        fi

        # Verify installation
        if ! command -v python3 &> /dev/null; then
            echo "‚ùå Python 3 installation failed"
            exit 1
        fi

        echo "‚úÖ Python 3 installed successfully!"
    fi
}

# ============================================
# Check and install cloudflared if needed
# ============================================
check_and_install_cloudflared() {
    if ! command -v cloudflared &> /dev/null; then
        echo ""
        echo "üì¶ cloudflared not found. Installing Cloudflare Tunnel..."
        echo ""

        # Detect OS and install cloudflared
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS
            if command -v brew &> /dev/null; then
                brew install cloudflared
            else
                echo "‚ö†Ô∏è  Homebrew not found. Installing via download..."
                curl -L --output /usr/local/bin/cloudflared https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-darwin-amd64
                sudo chmod +x /usr/local/bin/cloudflared
            fi
        elif [[ -f /etc/os-release ]]; then
            . /etc/os-release
            if [[ "$ID" == "amzn" ]] || [[ "$ID_LIKE" == *"rhel"* ]]; then
                # Amazon Linux / RHEL-based
                wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.rpm
                sudo rpm -i cloudflared-linux-amd64.rpm
                rm -f cloudflared-linux-amd64.rpm
            elif [[ "$ID" == "ubuntu" ]] || [[ "$ID" == "debian" ]] || [[ "$ID_LIKE" == *"debian"* ]]; then
                # Debian/Ubuntu
                wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
                sudo dpkg -i cloudflared-linux-amd64.deb
                rm -f cloudflared-linux-amd64.deb
            else
                echo "‚ö†Ô∏è  Unsupported Linux distribution: $ID"
                echo "   Please install cloudflared manually: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/"
                return 1
            fi
        else
            echo "‚ö†Ô∏è  Unsupported operating system"
            echo "   Please install cloudflared manually: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/"
            return 1
        fi

        # Verify installation
        if ! command -v cloudflared &> /dev/null; then
            echo "‚ùå cloudflared installation failed"
            return 1
        fi

        echo "‚úÖ cloudflared installed successfully!"
    fi
    return 0
}

# ============================================
# Self-installation check
# ============================================
install_script() {
    echo ""
    echo "üîß Installing dt-setup command..."
    
    # Detect if we should default to global or local
    if [ "$(id -u)" -eq 0 ]; then
        TARGET_DIR="$DEFAULT_GLOBAL_DIR"
        IS_GLOBAL=true
    else
        # Default to local install for non-root users (Zero Touch)
        TARGET_DIR="$DEFAULT_LOCAL_DIR"
        IS_GLOBAL=false
        echo "   Target: $TARGET_DIR (Local User)"
    fi

    echo "   Installing to $TARGET_DIR..."
    
    # Create directory if missing
    if [ "$IS_GLOBAL" = true ]; then
        if [ ! -d "$TARGET_DIR" ]; then
             sudo mkdir -p "$TARGET_DIR"
        fi
        CP_CMD="sudo cp"
        CHMOD_CMD="sudo chmod"
        TEE_CMD="sudo tee"
    else
        mkdir -p "$TARGET_DIR"
        CP_CMD="cp"
        CHMOD_CMD="chmod"
        TEE_CMD="tee"
    fi

    # Make script executable
    chmod +x "$0"
    chmod +x "$CONFIGURE_PY"

    # Copy script and store the project directory
    if $CP_CMD "$0" "$TARGET_DIR/$COMMAND_NAME" && $CHMOD_CMD +x "$TARGET_DIR/$COMMAND_NAME" \
        && echo "$SCRIPT_DIR" | $TEE_CMD "$TARGET_DIR/.dt-setup-project-dir" > /dev/null; then
        echo ""
        echo "‚úÖ dt-setup installed successfully!"
        
        # Handle PATH for locally installed
        if [ "$IS_GLOBAL" = false ]; then
             if [[ ":$PATH:" != *":$TARGET_DIR:"* ]]; then
                 echo "‚ö†Ô∏è  $TARGET_DIR is not in your PATH."
                 echo "   Adding to ~/.bashrc and ~/.zshrc..."
                 echo "export PATH=\"\$PATH:$TARGET_DIR\"" >> "$HOME/.bashrc"
                 [ -f "$HOME/.zshrc" ] && echo "export PATH=\"\$PATH:$TARGET_DIR\"" >> "$HOME/.zshrc"
                 echo "   Please restart your shell or run: source ~/.bashrc"
             fi
        fi
        
        echo "   You can now run 'dt-setup' from any directory"
        echo ""
    else
        echo ""
        echo "‚ùå Installation failed."
        return 1
    fi

    # Configure sudoers for systemd service management (Linux only)
    # Only if user wants to enable service management
    if [[ -f /etc/os-release ]] && command -v systemctl &> /dev/null; then
        echo "üîê Configuring system integration..."
        
        # Check if we have sudo access or need to ask
        NEED_SUDO_PASS=true
        if sudo -n true 2>/dev/null; then
            NEED_SUDO_PASS=false
        fi
        
        if [ "$IS_GLOBAL" = false ]; then
             if [ "$NEED_SUDO_PASS" = true ]; then
                 echo "   ‚ö†Ô∏è  Sudo password required to enable system service (one-time setup)."
                 echo "      (Press Enter to continue or Ctrl+C to skip service setup)"
                 read -r _ignored
             fi
        fi
        
        CURRENT_USER=$(whoami)
        SUDOERS_FILE="/etc/sudoers.d/digital-twin"
        
        # Write sudoers file
        if echo "# Digital Twin - limited sudo
$CURRENT_USER ALL=(ALL) NOPASSWD: /usr/bin/systemctl restart digital-twin
$CURRENT_USER ALL=(ALL) NOPASSWD: /usr/bin/systemctl start digital-twin
$CURRENT_USER ALL=(ALL) NOPASSWD: /usr/bin/systemctl stop digital-twin
$CURRENT_USER ALL=(ALL) NOPASSWD: /usr/bin/systemctl status digital-twin
$CURRENT_USER ALL=(ALL) NOPASSWD: /bin/systemctl restart digital-twin
$CURRENT_USER ALL=(ALL) NOPASSWD: /bin/systemctl start digital-twin
$CURRENT_USER ALL=(ALL) NOPASSWD: /bin/systemctl stop digital-twin
$CURRENT_USER ALL=(ALL) NOPASSWD: /bin/systemctl status digital-twin" | sudo tee "$SUDOERS_FILE" > /dev/null; then
            sudo chmod 440 "$SUDOERS_FILE"
            echo "‚úÖ Integration complete"
            
            # Auto-enable service?
            # We need to install the service file first? Auto-update handles it?
            # Or dt-setup should ensure service file is installed.
            SERVICE_SOURCE="$SCRIPT_DIR/digital-twin.service"
            
            if [ -f "$SERVICE_SOURCE" ]; then
                 echo "üîß Generating service file for current user/path..."
                 
                 # Create temp file with correct paths
                 TEMP_SERVICE=$(mktemp)
                 cp "$SERVICE_SOURCE" "$TEMP_SERVICE"
                 
                 # Update User, Group, WorkingDirectory, ExecStart
                 # Use | as delimiter for sed to avoid path issues
                 sed -i "s|User=.*|User=$CURRENT_USER|g" "$TEMP_SERVICE"
                 sed -i "s|Group=.*|Group=$(id -gn)|g" "$TEMP_SERVICE"
                 sed -i "s|WorkingDirectory=.*|WorkingDirectory=$SCRIPT_DIR|g" "$TEMP_SERVICE"
                 # Update ExecStart to match venv path
                 sed -i "s|ExecStart=.*|ExecStart=$SCRIPT_DIR/venv/bin/python src/watchdog.py|g" "$TEMP_SERVICE"
                 # Update PATH environment variable if present
                 sed -i "s|Environment=\"PATH=.*|Environment=\"PATH=$SCRIPT_DIR/venv/bin:/usr/local/bin:/usr/bin:/bin\"|g" "$TEMP_SERVICE"
                 
                 echo "   Installing service file..."
                 sudo cp "$TEMP_SERVICE" "/etc/systemd/system/digital-twin.service"
                 rm -f "$TEMP_SERVICE"
                 
                 sudo systemctl daemon-reload
                 sudo systemctl enable digital-twin
                 echo "‚úÖ Service enabled"
            else
                 echo "‚ö†Ô∏è  Service file not found at $SERVICE_SOURCE"
            fi
            
        else
            echo "‚ö†Ô∏è  Failed to configure system integration (skipping)"
        fi
    fi

    return 0
}

# Check if running locally and not installed (checked by presence in common paths)
# We check if 'dt-setup' command exists in PATH and if it resolves to this script??
# Simpler: If argument 0 is relative path, prompt install
if [[ "$0" == "./"* ]] || [[ "$0" == *"/dt-setup" ]]; then
    # Check if installed versions exist
    INSTALLED_GLOBAL="$DEFAULT_GLOBAL_DIR/$COMMAND_NAME"
    INSTALLED_LOCAL="$DEFAULT_LOCAL_DIR/$COMMAND_NAME"
    
    IS_INSTALLED=false
    if [ -f "$INSTALLED_GLOBAL" ] || [ -f "$INSTALLED_LOCAL" ]; then
        IS_INSTALLED=true
    fi

    if [ "$IS_INSTALLED" = false ]; then 
        if [[ "$1" != "--help" && "$1" != "-h" && "$1" != "help" && "$1" != "--skip-install" ]]; then
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "  Welcome to Digital Twin Setup!"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "First-time setup detected."
            echo ""
    
            # Auto-install without prompting (Zero Touch)
            # read -p "Install dt-setup command? (recommended) [Y/n]: " install_choice
            install_choice="Y" # Force yes
    
            if [[ "$install_choice" =~ ^[Yy]$ ]]; then
                install_script
            else
                echo ""
                echo "‚è≠Ô∏è  Skipping installation."
                echo "   You can install later with: ./dt-setup"
                echo ""
            fi
        fi
    fi
fi

# ============================================
# Auto-install dependencies if needed
# ============================================
check_and_install_dependencies() {
    echo "üì¶ Checking dependencies..."
    echo ""

    # Check if requirements.txt exists
    if [ ! -f "$REQUIREMENTS_TXT" ]; then
        echo "‚ö†Ô∏è  Warning: requirements.txt not found at $REQUIREMENTS_TXT"
        echo "   Skipping dependency installation."
        echo ""
        return
    fi

    # ALWAYS check/install dependencies to catch new requirements (like litellm/chromadb)
    echo "Running: pip install -r requirements.txt"
    echo ""

    # On Linux, install CPU-only PyTorch first to avoid 800MB+ CUDA bloat
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "‚ö° Installing CPU-only PyTorch (Linux)..."
        python3 -m pip install torch --index-url https://download.pytorch.org/whl/cpu
    fi

    if python3 -m pip install -r "$REQUIREMENTS_TXT"; then
        echo ""
        echo "‚úÖ Dependencies installed/verified successfully!"
        echo ""
    else
        echo ""
        echo "‚ùå Failed to install dependencies."
        echo "   Please run manually: pip install -r requirements.txt"
        echo ""
        exit 1
    fi
}

# Check Python installation first (unless --help)
if [[ "$1" != "--help" && "$1" != "-h" && "$1" != "help" ]]; then
    check_python
fi

# Create data directories and set permissions if needed
mkdir -p "$SCRIPT_DIR/data" "$SCRIPT_DIR/logs"
chmod 755 "$SCRIPT_DIR/data" "$SCRIPT_DIR/logs"

# Check dependencies before running configuration (unless --help or start/run)
if [[ "$1" != "--help" && "$1" != "-h" && "$1" != "help" && "$1" != "start" && "$1" != "run" ]]; then
    check_and_install_dependencies
fi

# Ensure correct permissions (recursive)
# This prevents root-owned files from breaking the service
fix_permissions() {
    # Only fix if running as root
    if [ "$(id -u)" -eq 0 ]; then
        TARGET_USER="${SUDO_USER:-ec2-user}"
        # Avoid changing ownership if user is root (e.g. really running as root)
        if [ "$TARGET_USER" != "root" ] && id "$TARGET_USER" &>/dev/null; then
            # Avoid logging if we are just checking help
            if [[ "$1" != "--help" && "$1" != "-h" ]]; then
                 echo "üîß Fixing permissions for user: $TARGET_USER"
            fi
            chown -R "$TARGET_USER:$TARGET_USER" "$SCRIPT_DIR"
            
            # Directories: 755
            find "$SCRIPT_DIR" -type d -exec chmod 755 {} +
            
            # Files: 644 (read/write owner, read others)
            find "$SCRIPT_DIR" -type f -not -name "dt-setup" -not -name "*.sh" -not -name "*.py" -exec chmod 644 {} +
            
            # Executables should remain executable
            chmod +x "$SCRIPT_DIR/dt-setup" "$SCRIPT_DIR/auto-update.sh" "$SCRIPT_DIR/configure.py"
            
            # .env: 600 (read/write owner ONLY) - Security
            if [ -f "$SCRIPT_DIR/.env" ]; then
                chmod 600 "$SCRIPT_DIR/.env"
            fi

            # Ensure logs are writable
            if [ -d "$SCRIPT_DIR/logs" ]; then
                chmod 775 "$SCRIPT_DIR/logs"
            fi
            if [ -d "$SCRIPT_DIR/data" ]; then
                chmod 775 "$SCRIPT_DIR/data"
            fi
        fi
    fi
}
trap fix_permissions EXIT

# ============================================
# Start bot helper
# ============================================
start_bot_if_requested() {
    # Only offer to start for full setup (not partial configs)
    if [[ "$1" == "" || "$1" == "digital-twin" || "$1" == "all" || "$1" == "full" ]]; then
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        read -p "Start the bot now? [Y/n]: " start_choice
        start_choice=${start_choice:-Y}

        if [[ "$start_choice" =~ ^[Yy]$ ]]; then
            echo ""
            echo "üöÄ Starting Digital Twin bot..."
            echo ""

            # Check if Cloudflare Tunnel is configured and start it
            if [ -f "$SCRIPT_DIR/.env" ] && grep -q "^CLOUDFLARE_TUNNEL_TOKEN=" "$SCRIPT_DIR/.env"; then
                echo "üåê Starting Cloudflare Tunnel..."
                "$SCRIPT_DIR/dt-setup" tunnel-start
            fi

            # Check if we're in the right directory
            if [ -f "$SCRIPT_DIR/src/main.py" ]; then
                cd "$SCRIPT_DIR"
                
                # Check if systemd is configured and working
                if command -v systemctl &> /dev/null && systemctl is-enabled --quiet digital-twin 2>/dev/null; then
                    echo "üöÄ Starting service via systemd..."
                    sudo systemctl start digital-twin
                    sudo systemctl status digital-twin --no-pager | head -15
                    echo ""
                    echo "‚úÖ Bot started in background (Systemd Service)"
                    echo "   View logs: journalctl -u digital-twin -f"
                else
                    echo "üöÄ Starting bot (Foreground)..."
                    python3 -m src.main
                fi
            else
                echo "‚ùå Error: src/main.py not found"
                echo "   Please run manually: python -m src.main"
            fi
        else
            echo ""
            echo "‚úÖ Setup complete!"
            echo ""
            echo "To start the bot later, run:"
            echo "  dt-setup start"
            echo ""
        fi
    fi
}

# Parse arguments and map to configure.py flags
case "$1" in
    "")
        # No arguments - run full wizard
        python3 "$CONFIGURE_PY"
        start_bot_if_requested ""
        ;;
    "digital-twin"|"all"|"full")
        # Full setup
        python3 "$CONFIGURE_PY"
        start_bot_if_requested "$1"
        ;;
    "core"|"api"|"keys")
        # Core API keys
        python3 "$CONFIGURE_PY" --core-only
        ;;
    "telegram"|"tg")
        # Telegram bot
        python3 "$CONFIGURE_PY" --telegram-only
        ;;
    "email"|"mail")
        # Email configuration
        python3 "$CONFIGURE_PY" --email-only
        ;;
    "calendar"|"cal")
        # Calendar configuration
        python3 "$CONFIGURE_PY" --calendar-only
        ;;
    "tunnel"|"cf"|"cloudflare")
        # Cloudflare Tunnel configuration
        python3 "$CONFIGURE_PY" --tunnel-only
        ;;
    "tunnel-start")
        # Start Cloudflare Tunnel
        echo ""
        echo "üåê Starting Cloudflare Tunnel..."
        echo ""

        # Check if cloudflared is installed
        if ! command -v cloudflared &> /dev/null; then
            echo "‚ö†Ô∏è  cloudflared not found. Installing..."
            check_and_install_cloudflared
        fi

        # Check if tunnel token is configured
        if [ -f "$SCRIPT_DIR/.env" ]; then
            TUNNEL_TOKEN=$(grep "^CLOUDFLARE_TUNNEL_TOKEN=" "$SCRIPT_DIR/.env" | cut -d'=' -f2)
            if [ -z "$TUNNEL_TOKEN" ]; then
                echo "‚ùå Tunnel token not found in .env file"
                echo "   Run: dt-setup tunnel"
                exit 1
            fi

            # Start tunnel
            echo "Starting tunnel in background..."
            nohup cloudflared tunnel --no-autoupdate run --token "$TUNNEL_TOKEN" > "$SCRIPT_DIR/logs/tunnel.log" 2>&1 &
            echo $! > "$SCRIPT_DIR/tunnel.pid"
            echo "‚úÖ Tunnel started (PID: $!)"
            echo "   Logs: $SCRIPT_DIR/logs/tunnel.log"
        else
            echo "‚ùå .env file not found"
            echo "   Run: dt-setup tunnel"
            exit 1
        fi
        echo ""
        ;;
    "tunnel-stop")
        # Stop Cloudflare Tunnel
        echo ""
        echo "üõë Stopping Cloudflare Tunnel..."
        echo ""

        if [ -f "$SCRIPT_DIR/tunnel.pid" ]; then
            PID=$(cat "$SCRIPT_DIR/tunnel.pid")
            if kill -0 "$PID" 2>/dev/null; then
                kill "$PID"
                rm -f "$SCRIPT_DIR/tunnel.pid"
                echo "‚úÖ Tunnel stopped (PID: $PID)"
            else
                echo "‚ö†Ô∏è  Tunnel process not found (stale PID)"
                rm -f "$SCRIPT_DIR/tunnel.pid"
            fi
        elif pgrep -f "cloudflared tunnel" > /dev/null; then
            pkill -f "cloudflared tunnel"
            echo "‚úÖ Tunnel stopped"
        else
            echo "‚ö†Ô∏è  Tunnel is not running"
        fi
        echo ""
        ;;
    "tunnel-status")
        # Check Cloudflare Tunnel status
        echo ""
        echo "üåê Cloudflare Tunnel Status"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""

        if [ -f "$SCRIPT_DIR/tunnel.pid" ]; then
            PID=$(cat "$SCRIPT_DIR/tunnel.pid")
            if kill -0 "$PID" 2>/dev/null; then
                echo "‚úÖ Status: Running (PID: $PID)"
                ps aux | grep "[c]loudflared"
            else
                echo "‚ùå Status: Not running (stale PID)"
                rm -f "$SCRIPT_DIR/tunnel.pid"
            fi
        elif pgrep -f "cloudflared tunnel" > /dev/null; then
            echo "‚úÖ Status: Running"
            ps aux | grep "[c]loudflared"
        else
            echo "‚ùå Status: Not running"
            echo ""
            echo "To start the tunnel:"
            echo "  dt-setup tunnel-start"
        fi
        echo ""
        ;;
    "start"|"run")
        # Start the bot
        echo ""
        echo "üöÄ Starting Digital Twin bot..."
        echo ""

        if [ -f "$SCRIPT_DIR/src/main.py" ]; then
            cd "$SCRIPT_DIR"
            python3 -m src.main
        else
            echo "‚ùå Error: src/main.py not found"
            echo "   Make sure you're in the digital-twin directory"
            exit 1
        fi
        ;;
    "stop")
        # Stop the bot
        echo ""
        echo "üõë Stopping Digital Twin bot..."
        echo ""

        # Try systemd first
        if systemctl is-active --quiet digital-twin 2>/dev/null; then
            sudo systemctl stop digital-twin
            echo "‚úÖ Bot stopped (systemd service)"
        elif pgrep -f "python.*src.main" > /dev/null; then
            # Kill Python process
            pkill -f "python.*src.main"
            echo "‚úÖ Bot stopped (process killed)"
        else
            echo "‚ö†Ô∏è  Bot is not running"
        fi
        echo ""
        ;;
    "restart")
        # Restart the bot
        echo ""
        echo "üîÑ Restarting Digital Twin bot..."
        echo ""

        # Try systemd first
        if systemctl is-enabled --quiet digital-twin 2>/dev/null; then
            sudo systemctl restart digital-twin
            echo "‚úÖ Bot restarted (systemd service)"
        else
            # Stop if running
            if pgrep -f "python.*src.main" > /dev/null; then
                pkill -f "python.*src.main"
                sleep 2
            fi

            # Start again
            if [ -f "$SCRIPT_DIR/src/main.py" ]; then
                cd "$SCRIPT_DIR"
                python3 -m src.main &
                echo "‚úÖ Bot restarted (background process)"
            else
                echo "‚ùå Error: src/main.py not found"
                exit 1
            fi
        fi
        echo ""
        ;;
    "status")
        # Check bot status
        echo ""
        echo "üìä Digital Twin Status"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""

        # Check systemd
        if systemctl is-active --quiet digital-twin 2>/dev/null; then
            echo "‚úÖ Status: Running (systemd service)"
            sudo systemctl status digital-twin --no-pager | head -15
        elif pgrep -f "python.*src.main" > /dev/null; then
            echo "‚úÖ Status: Running (process)"
            ps aux | grep "[p]ython.*src.main"
        else
            echo "‚ùå Status: Not running"
            echo ""
            echo "To start the bot:"
            echo "  dt-setup start"
        fi
        echo ""
        ;;
    "auto-update")
        # Auto-update management
        case "$2" in
            "enable")
                # Enable auto-updates
                FREQUENCY="${3:-daily}"
                echo ""
                echo "üîÑ Enabling auto-updates ($FREQUENCY)..."
                echo ""

                # Create systemd timer (if on Linux)
                if command -v systemctl &> /dev/null; then
                    # Determine OnCalendar value based on frequency
                    case "$FREQUENCY" in
                        "hourly")
                            CALENDAR="hourly"
                            ;;
                        "daily"|"nightly")
                            CALENDAR="*-*-* 03:00:00"  # 3 AM daily
                            ;;
                        "weekly")
                            CALENDAR="Sun *-*-* 03:00:00"  # Sunday 3 AM
                            ;;
                        *)
                            echo "‚ùå Invalid frequency: $FREQUENCY"
                            echo "   Valid options: hourly, daily, weekly"
                            exit 1
                            ;;
                    esac

                    # Update timer file with chosen frequency
                    TIMER_FILE="/etc/systemd/system/digital-twin-autoupdate.timer"
                    if [ -f "$SCRIPT_DIR/deploy/systemd/digital-twin-autoupdate.timer" ]; then
                        # Copy and modify timer file
                        sudo cp "$SCRIPT_DIR/deploy/systemd/digital-twin-autoupdate.service" /etc/systemd/system/
                        sudo cp "$SCRIPT_DIR/deploy/systemd/digital-twin-autoupdate.timer" /etc/systemd/system/

                        # Update OnCalendar in timer file
                        sudo sed -i "s|OnCalendar=.*|OnCalendar=$CALENDAR|" "$TIMER_FILE"

                        # Reload and enable timer
                        sudo systemctl daemon-reload
                        sudo systemctl enable digital-twin-autoupdate.timer
                        sudo systemctl start digital-twin-autoupdate.timer

                        echo "‚úÖ Auto-updates enabled ($FREQUENCY)"
                        echo ""
                        echo "Check status:"
                        echo "  dt-setup auto-update status"
                        echo ""
                        echo "Run update now:"
                        echo "  dt-setup auto-update now"
                    else
                        echo "‚ùå Timer files not found in deploy/systemd/"
                        exit 1
                    fi
                else
                    echo "‚ö†Ô∏è  systemd not available"
                    echo "   Auto-updates work best with systemd (Linux)"
                    echo ""
                    echo "Alternative: Set up a cron job manually:"
                    echo "  crontab -e"
                    echo "  Add: 0 3 * * * $SCRIPT_DIR/auto-update.sh"
                fi
                echo ""
                ;;
            "disable")
                # Disable auto-updates
                echo ""
                echo "üõë Disabling auto-updates..."
                echo ""

                if systemctl is-enabled --quiet digital-twin-autoupdate.timer 2>/dev/null; then
                    sudo systemctl stop digital-twin-autoupdate.timer
                    sudo systemctl disable digital-twin-autoupdate.timer
                    echo "‚úÖ Auto-updates disabled"
                else
                    echo "‚ö†Ô∏è  Auto-updates not enabled"
                fi
                echo ""
                ;;
            "now")
                # Run update check now
                echo ""
                echo "üîÑ Running update check..."
                echo ""
                "$SCRIPT_DIR/auto-update.sh"
                ;;
            "status")
                # Check auto-update status
                echo ""
                echo "üîÑ Auto-Update Status"
                echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                echo ""

                if systemctl is-active --quiet digital-twin-autoupdate.timer 2>/dev/null; then
                    echo "‚úÖ Status: Enabled"
                    echo ""
                    systemctl status digital-twin-autoupdate.timer --no-pager | head -15
                    echo ""
                    echo "Next run:"
                    systemctl list-timers digital-twin-autoupdate.timer --no-pager
                elif command -v systemctl &> /dev/null; then
                    echo "‚ùå Status: Disabled"
                    echo ""
                    echo "To enable:"
                    echo "  dt-setup auto-update enable [hourly|daily|weekly]"
                else
                    echo "‚ö†Ô∏è  systemd not available"
                    echo ""
                    echo "Check cron jobs:"
                    echo "  crontab -l | grep auto-update"
                fi
                echo ""
                ;;
            *)
                echo ""
                echo "Usage: dt-setup auto-update <command>"
                echo ""
                echo "Commands:"
                echo "  enable [frequency]  Enable auto-updates (hourly/daily/weekly)"
                echo "  disable             Disable auto-updates"
                echo "  now                 Run update check now"
                echo "  status              Check auto-update status"
                echo ""
                echo "Examples:"
                echo "  dt-setup auto-update enable daily    # Enable daily updates"
                echo "  dt-setup auto-update enable weekly   # Enable weekly updates"
                echo "  dt-setup auto-update now             # Check for updates now"
                echo ""
                ;;
        esac
        ;;
    "talents")
        # Show talent catalog
        cd "$SCRIPT_DIR"
        python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from src.core.talents.catalog import TalentCatalog
TalentCatalog().print_status()
"
        ;;
    "talent")
        # Build a talent using the one-shot agent
        if [ -z "$2" ]; then
            echo ""
            echo "Usage: dt-setup talent <talent-name>"
            echo ""
            echo "Examples:"
            echo "  dt-setup talent Post-on-X     # Build X posting talent"
            echo "  dt-setup talent LinkedIn       # Build LinkedIn talent"
            echo "  dt-setup talent WhatsApp       # Build WhatsApp talent"
            echo ""
            echo "Available talents:"
            cd "$SCRIPT_DIR"
            python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from src.core.talents.catalog import TalentCatalog
TalentCatalog().print_status()
"
        else
            cd "$SCRIPT_DIR"
            python3 -m src.core.talents.builder "$2"
        fi
        ;;
    "--help"|"-h"|"help")
        # Show help
        cat << EOF
Digital Twin Setup - Complete Automation

ONE command does everything:
  1. ‚úÖ Installs itself globally (first run)
  2. ‚úÖ Installs Python dependencies
  3. ‚úÖ Runs interactive configuration
  4. ‚úÖ Auto-detects email providers
  5. ‚úÖ Updates .env file
  6. ‚úÖ Ready to run!

Usage:
  dt-setup                Full setup wizard (all tools)

  Bot Management:
  dt-setup start          Start the bot
  dt-setup stop           Stop the bot
  dt-setup restart        Restart the bot
  dt-setup status         Check bot status

  Talents (Capabilities):
  dt-setup talents                List all talents and their status
  dt-setup talent <name>          Build a new talent (agent-powered)

  Configure Existing:
  dt-setup core           Configure API keys
  dt-setup telegram       Configure Telegram
  dt-setup email          Configure Email talent
  dt-setup calendar       Configure Calendar talent
  dt-setup tunnel         Configure Cloudflare Tunnel

  Tunnel Management:
  dt-setup tunnel-start   Start Cloudflare Tunnel
  dt-setup tunnel-stop    Stop Cloudflare Tunnel
  dt-setup tunnel-status  Check tunnel status

  Auto-Update:
  dt-setup auto-update enable [freq]  Enable auto-updates (hourly/daily/weekly)
  dt-setup auto-update disable        Disable auto-updates
  dt-setup auto-update now            Check for updates now
  dt-setup auto-update status         Check auto-update status

Examples:
  dt-setup                          # Full wizard
  dt-setup talents                  # View all talents
  dt-setup talent Post-on-X         # Build X posting talent
  dt-setup talent LinkedIn          # Build LinkedIn talent
  dt-setup start                    # Start the bot
  dt-setup email                    # Configure Email talent
  dt-setup auto-update enable daily # Enable daily auto-updates

First-time setup (TWO commands!):
  git clone https://github.com/AmplifyCo/digital-twin.git
  cd digital-twin && ./dt-setup

  That's it! The script:
  ‚Ä¢ Installs itself globally
  ‚Ä¢ Installs all dependencies
  ‚Ä¢ Asks for Claude API key
  ‚Ä¢ Asks for Gmail credentials (optional)
  ‚Ä¢ Configures everything
  ‚Ä¢ Offers to start the bot immediately
  ‚Ä¢ Bot is running!

After first run:
  dt-setup                # Works from anywhere (like git, python)

For advanced options:
  python3 configure.py --help

EOF
        ;;
    *)
        # Unknown argument - pass through to configure.py
        python3 "$CONFIGURE_PY" "$@"
        ;;
esac
