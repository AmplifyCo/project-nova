"""Vulnerability scanner for Python packages and system updates."""

import asyncio
import json
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class Vulnerability:
    """Represents a package vulnerability."""
    package: str
    installed_version: str
    vulnerable_versions: str
    advisory: str
    severity: str  # critical, high, medium, low
    fixed_version: Optional[str] = None
    cve_id: Optional[str] = None


class VulnerabilityScanner:
    """Scans for vulnerabilities in Python packages and system packages."""

    def __init__(self, bash_tool=None):
        """Initialize vulnerability scanner.

        Args:
            bash_tool: BashTool instance for running commands
        """
        self.bash_tool = bash_tool
        self.last_scan = None
        self.vulnerabilities: List[Vulnerability] = []

    async def scan_python_packages(self) -> List[Vulnerability]:
        """Scan Python packages for vulnerabilities using pip-audit.

        Returns:
            List of vulnerabilities found
        """
        logger.info("Scanning Python packages for vulnerabilities...")

        vulnerabilities = []

        try:
            # Use pip-audit if available
            result = await self.bash_tool.execute(
                "pip-audit --format json --desc on",
                timeout=300
            )

            if result.success:
                vulnerabilities.extend(self._parse_pip_audit(result.output))
            else:
                logger.warning(f"pip-audit not available: {result.error}")
                # Fallback to safety
                result = await self.bash_tool.execute(
                    "safety check --json",
                    timeout=300
                )
                if result.success:
                    vulnerabilities.extend(self._parse_safety(result.output))

        except Exception as e:
            logger.error(f"Error scanning Python packages: {e}")

        self.vulnerabilities = vulnerabilities
        self.last_scan = datetime.now()

        logger.info(f"Found {len(vulnerabilities)} Python package vulnerabilities")
        return vulnerabilities

    async def scan_system_packages(self) -> List[Dict[str, str]]:
        """Scan system packages for available security updates.

        Returns:
            List of packages with security updates
        """
        logger.info("Scanning for system security updates...")

        updates = []

        try:
            # Check for yum security updates
            result = await self.bash_tool.execute(
                "yum check-update --security --quiet",
                timeout=120
            )

            # yum returns 100 if updates are available
            if result.metadata.get("return_code") == 100:
                # Parse output to get package list
                for line in result.output.strip().split('\n'):
                    if line and not line.startswith('#'):
                        parts = line.split()
                        if len(parts) >= 2:
                            updates.append({
                                "package": parts[0],
                                "version": parts[1],
                                "type": "security"
                            })

        except Exception as e:
            logger.error(f"Error scanning system packages: {e}")

        logger.info(f"Found {len(updates)} system security updates")
        return updates

    async def get_outdated_packages(self) -> List[Dict[str, str]]:
        """Get list of outdated Python packages.

        Returns:
            List of outdated packages
        """
        logger.info("Checking for outdated Python packages...")

        outdated = []

        try:
            result = await self.bash_tool.execute(
                "pip list --outdated --format json",
                timeout=60
            )

            if result.success:
                outdated = json.loads(result.output)

        except Exception as e:
            logger.error(f"Error getting outdated packages: {e}")

        logger.info(f"Found {len(outdated)} outdated Python packages")
        return outdated

    def _parse_pip_audit(self, output: str) -> List[Vulnerability]:
        """Parse pip-audit JSON output.

        Args:
            output: JSON output from pip-audit

        Returns:
            List of Vulnerability objects
        """
        vulnerabilities = []

        try:
            data = json.loads(output)

            for vuln_data in data.get("vulnerabilities", []):
                vuln = Vulnerability(
                    package=vuln_data.get("name", "unknown"),
                    installed_version=vuln_data.get("version", "unknown"),
                    vulnerable_versions=vuln_data.get("vulnerable_versions", ""),
                    advisory=vuln_data.get("description", "No description"),
                    severity=vuln_data.get("severity", "unknown").lower(),
                    fixed_version=vuln_data.get("fix_versions", [None])[0],
                    cve_id=vuln_data.get("id", None)
                )
                vulnerabilities.append(vuln)

        except json.JSONDecodeError:
            logger.error("Failed to parse pip-audit output")
        except Exception as e:
            logger.error(f"Error parsing pip-audit: {e}")

        return vulnerabilities

    def _parse_safety(self, output: str) -> List[Vulnerability]:
        """Parse safety JSON output.

        Args:
            output: JSON output from safety

        Returns:
            List of Vulnerability objects
        """
        vulnerabilities = []

        try:
            data = json.loads(output)

            for vuln_data in data:
                vuln = Vulnerability(
                    package=vuln_data[0],
                    installed_version=vuln_data[2],
                    vulnerable_versions=vuln_data[1],
                    advisory=vuln_data[3],
                    severity="high",  # safety doesn't provide severity
                    cve_id=vuln_data[4] if len(vuln_data) > 4 else None
                )
                vulnerabilities.append(vuln)

        except json.JSONDecodeError:
            logger.error("Failed to parse safety output")
        except Exception as e:
            logger.error(f"Error parsing safety: {e}")

        return vulnerabilities

    def get_critical_vulnerabilities(self) -> List[Vulnerability]:
        """Get only critical and high severity vulnerabilities.

        Returns:
            List of critical/high vulnerabilities
        """
        return [
            v for v in self.vulnerabilities
            if v.severity in ["critical", "high"]
        ]

    def get_scan_summary(self) -> Dict[str, Any]:
        """Get summary of last scan.

        Returns:
            Dictionary with scan summary
        """
        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "unknown": 0
        }

        for vuln in self.vulnerabilities:
            severity_counts[vuln.severity] = severity_counts.get(vuln.severity, 0) + 1

        return {
            "last_scan": self.last_scan.isoformat() if self.last_scan else None,
            "total_vulnerabilities": len(self.vulnerabilities),
            "severity_breakdown": severity_counts,
            "critical_packages": [
                v.package for v in self.get_critical_vulnerabilities()
            ]
        }
